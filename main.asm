;Copyright (C) 2019 Gugolple

;This program is free software; you can redistribute it and/or
;modify it under the terms of the GNU General Public License
;as published by the Free Software Foundation; either version 2
;of the License, or (at your option) any later version.

;This program is distributed in the hope that it will be useful,
;but WITHOUT ANY WARRANTY; without even the implied warranty of
;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;GNU General Public License for more details.

;You should have received a copy of the GNU General Public License
;along with this program; if not, write to the Free Software
;Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
    
    
    
; TODO INSERT CONFIG CODE HERE USING CONFIG BITS GENERATOR
#include <p16f690.inc>
    __config (_HS_OSC & _WDT_OFF & _PWRTE_ON & _MCLRE_OFF & _CP_OFF & _CPD_OFF & _BOR_OFF & _IESO_OFF & _FCMEN_ON)
    
RES_VECT  CODE    0x0000            ; processor reset vector
    CLRF    INTCON		    ; disable interrupts
    GOTO    START                   ; go to beginning of program

Int_Handler CODE    0x0004
    RETFIE

    
    
GET_GREEN
    MOVWF   TABLE_TEMPORAL	;PUT INDEX OUT OF WAY
    MOVLW   HIGH COLORS_GREEN	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAG
    MOVF    TABLE_TEMPORAL,W	;RECOVER INDEX
    ANDLW   MAX_COLORS		;GET MAX 16
    ADDLW   COLORS_GREEN	;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL
GET_RED
    MOVWF   TABLE_TEMPORAL	;PUT INDEX OUT OF WAY
    MOVLW   HIGH COLORS_RED	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAGE
    MOVF    TABLE_TEMPORAL,W	;RECOVER INDEX
    ANDLW   MAX_COLORS		;GET MAX 16
    ADDLW   COLORS_RED		;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL
GET_BLUE
    MOVWF   TABLE_TEMPORAL	;PUT INDEX OUT OF WAY
    MOVLW   HIGH COLORS_BLUE	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAGE
    MOVF    TABLE_TEMPORAL,W	;RECOVER INDEX
    ANDLW   MAX_COLORS		;GET MAX 16
    ADDLW   COLORS_BLUE		;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL
    
PRINT_SCREEN			    ; Only works on bank 0 or 2
    BCF	STATUS,RP1		    ;FORCE BANK 0
    BCF	STATUS,RP0
    
    ;KEEP ALIVE ON BANK 0
    MOVLW	0x01		    ;REVERSED FILE
    MOVWF	B31
    CALL	RANDOM
    MOVWF	C31
    
    BSF	PORTC,RC7		    ; SET OUTPUT HIGH, START RESET
    MOVLW   .80
    MOVWF   CURRENT_COLUMN
    SEND_RESET_HIGH			    ; Reset >50 microseconds
	DECFSZ	CURRENT_COLUMN,F	    ; Tnstruction 0.4 * 3 (AMOUNT INST) 10MHz
	GOTO SEND_RESET_HIGH		    ;  = 1.2 microseconds
	
    BCF	PORTC,RC7		    ; SET OUTPUT LOW, START RESET
    MOVLW   .80
    MOVWF   CURRENT_COLUMN
    SEND_RESET			    ; Reset >50 microseconds
	DECFSZ	CURRENT_COLUMN,F	    ; Tnstruction 0.4 * 3 (AMOUNT INST) 10MHz
	GOTO SEND_RESET		    ;  = 1.2 microseconds
	
	
    MOVLW   ARRAY_START		    ; START INDIRECT ACCES TO FIRST WORD
    MOVWF   FSR			    
    
    MOVLW   SIZE_COL
    MOVWF   COLUMN_INDEX
    COLUMN_LOOP
	MOVLW	SIZE_B
	MOVWF	CURRENT_COLUMN_INDEX
	
	MOVF	INDF,W
	MOVWF	CURRENT_COLUMN	    ;LED PATTERN
	INCF	FSR,F
	
	MOVF	INDF,W
	MOVWF	CURRENT_COLOR	    ;LED COLOR
	INCF	FSR,F
	
	COLUMN_BIT
	MOVF	CURRENT_COLOR,W
	BTFSS   CURRENT_COLUMN,7	; IF CURRENT POSITIOS IS ON
	MOVLW   COLOR_BLACK
	MOVWF   TEMP_COLOR
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    ;GREEN
	    CALL    GET_GREEN
	    MOVWF   DISPLAY_COLOR
	    MOVLW   SIZE_B
	    MOVWF   CURRENT_DISPLAY_INDEX
	    GREEN_LOOP
		BTFSS   DISPLAY_COLOR,7	; IF 0 HIGHEST BIT
		GOTO    LOOP_GREEN_SHORT	; GO TO SHORT
		BSF	    PORTC,RC7		; LONG, 1
		NOP
		NOP
		BCF	    PORTC,RC7
		GOTO    LOOP_GREEN_END
		LOOP_GREEN_SHORT
		BSF	    PORTC,RC7		; SHORT, 0
		BCF	    PORTC,RC7
		LOOP_GREEN_END
		RLF	DISPLAY_COLOR,F
		DECFSZ  CURRENT_DISPLAY_INDEX,F
		GOTO GREEN_LOOP
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
		
	    ;RED
	    MOVF    TEMP_COLOR,W
	    CALL    GET_RED
	    MOVWF   DISPLAY_COLOR
	    MOVLW   SIZE_B
	    MOVWF   CURRENT_DISPLAY_INDEX
	    RED_LOOP
		BTFSS   DISPLAY_COLOR,7	; IF 0 HIGHEST BIT
		GOTO    LOOP_RED_SHORT	; GO TO SHORT
		BSF	    PORTC,RC7		; LONG, 1
		NOP
		NOP
		BCF	    PORTC,RC7
		GOTO    LOOP_RED_END
		LOOP_RED_SHORT
		BSF	    PORTC,RC7		; SHORT, 0
		BCF	    PORTC,RC7
		LOOP_RED_END
		RLF	DISPLAY_COLOR,F
		DECFSZ  CURRENT_DISPLAY_INDEX,F
		GOTO RED_LOOP
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
		
	    ;BLUE
	    MOVF    TEMP_COLOR,W
	    CALL    GET_BLUE
	    MOVWF   DISPLAY_COLOR
	    MOVLW   SIZE_B
	    MOVWF   CURRENT_DISPLAY_INDEX
	    BLUE_LOOP
		BTFSS   DISPLAY_COLOR,7	; IF 0 HIGHEST BIT
		GOTO    LOOP_BLUE_SHORT	; GO TO SHORT
		BSF	    PORTC,RC7		; LONG, 1
		NOP
		NOP
		BCF	    PORTC,RC7
		GOTO    LOOP_BLUE_END
		LOOP_BLUE_SHORT
		BSF	    PORTC,RC7		; SHORT, 0
		BCF	    PORTC,RC7
		LOOP_BLUE_END
		RLF	DISPLAY_COLOR,F
		DECFSZ  CURRENT_DISPLAY_INDEX,F
		GOTO BLUE_LOOP
		
	    ;BSF	PORTC,RC6	   
	    ;BCF	PORTC,RC6
	    RLF	CURRENT_COLUMN,F
	    DECFSZ  CURRENT_COLUMN_INDEX,F
	    GOTO COLUMN_BIT

	DECFSZ	COLUMN_INDEX,F
	GOTO	COLUMN_LOOP

    ;BCF	PORTC,RC6
    BSF PORTC,RC7	
    RETURN

;CONSTANTS
PATTERN		equ B'00000001'
SIZE_COL	equ .32
PLAYABLE_COLS   equ .16;.24
SIZE_B		equ .8
MAX_COLORS	equ 0x0F		    ;0-15 = 16 colors MASQUING LOGIC
ARRAY_START	equ 0x20
BANK1		equ 0x80
DROP_AMOUNT	equ .20
;SECTION JUST USED WHEN PRINTING
;MAY BE REUSED ONLY FOR TEMPORAL USE
COLUMN_INDEX	equ 0x60
CURRENT_COLUMN	equ 0x61
CURRENT_COLUMN_INDEX	equ 0x62
TABLE_TEMPORAL	equ 0x63
CURRENT_COLOR	equ 0x64
INDEXED_COLOR	equ 0x65
TEMP_COLOR	equ 0x66
DISPLAY_COLOR	equ 0x67
CURRENT_DISPLAY_INDEX	equ 0x68

;REUSE FOR REVERSE
REVERSE_TEMP	equ 0x60
REVERSE_RET	equ 0x61
REVERSE_COUNT	equ 0x62

MAX_ROTATIONS  equ	0x03		    ;0-3 = 4 MAQUING ROTATIONS
;REUSE FOR GET_PIECES
PIECE_TEMP	equ 0x63
SIZE_TEMP	equ 0x64
PIECE_START	equ 0x65
PIECE_TABLE	equ 0x66
PIECE_INTER	equ 0x67

	
;COMMONS BECAUSE BETWEEN 0x70-0x7F
LAST_STATE  equ 0x7F	;RB4,RB5,RB6,RB7 0xf0
PIECE_WIDTH equ	0x7E
LAST_POS_X  equ 0x7D
LAST_POS_Y  equ 0x7C
PIECE_SIZE  equ	0x7B
PIECE_3	    equ	0x7A
PIECE_2	    equ	0x79
PIECE_1	    equ	0x78
PIECE_0	    equ	0x77
PIECE_TYPE  equ	0x76
hiB	    equ 0x75
lowB	    equ 0x74
TEMP_REG    equ	0x73
OP_REG	    equ	0x72
DROP_COUNT  equ	0x71	; 
LEVEL	    equ	0x70	; CURRENT_LEVEL
	    
;COMMONS LOCALS MUST NOT OVERWRITE
TEMP_STATE  equ 0x6F
SCORE_L	    equ 0x6E
SCORE_M	    equ 0x6D
SCORE_H	    equ 0x6C
	    
;ROTATION
ROTATION_T  equ 0x6B
  
;REGISTERS USED WHEN PLACING PIECE AND CLEARING LINES
CHECK_TEMP  equ	0x6B  
CLEAR_TEMP  equ	0x6A
CLEAR_INDX  equ	0x69

CLEAR_T3    equ	0x68
CLEAR_T2    equ	0x67
CLEAR_T1    equ	0x66
CLEAR_T0    equ	0x65
	    

    
; BANK 1 MAPS, LOGIC ONLY    
  
;MAP OF DISPLAY MEMORY, MUST NOT REUSE
    cblock 0x20 ; 0x20 - 0x5F = 64 BYTES 
	B0,C0,B1,C1,B2,C2,B3,C3,B4,C4,B5,C5,B6,C6,B7,C7
	B8,C8,B9,C9,B10,C10,B11,C11,B12,C12,B13,C13,B14,C14,B15,C15
	B16,C16,B17,C17,B18,C18,B19,C19,B20,C20,B21,C21,B22,C22,B23,C23
	B24,C24,B25,C25,B26,C26,B27,C27,B28,C28,B29,C29,B30,C30,B31,C31
    endc


;COLORS_GREEN dt	0x00,0x20,0x00,0x00,0x20,0x20,0x00,0x20,0x10,0x00,0x00,0x10,0x10,0x00,0x20,0x00
;COLORS_RED dt	0x00,0x00,0x20,0x00,0x20,0x00,0x20,0x20,0x00,0x10,0x00,0x10,0x00,0x10,0x10,0x10
;COLORS_BLUE dt	0x00,0x00,0x00,0x20,0x00,0x20,0x20,0x20,0x00,0x00,0x10,0x00,0x10,0x10,0x00,0x20
    
;COLORS In 1/4 of brightness, overheating issues with the leds
COLORS_RED   dt	0x00,0x20,0x10,0x08,0x20,0x10,0x20,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08
COLORS_GREEN dt	0x00,0x20,0x10,0x08,0x00,0x00,0x20,0x10,0x20,0x10,0x20,0x10,0x00,0x00,0x00,0x00
COLORS_BLUE  dt	0x00,0x20,0x10,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x10,0x20,0x20,0x20,0x10
COLOR_BLACK equ 0x00 ; POSITION OF BLACK
 
;LISTA DE BLOQUES
 
;ORDER:	LI,S,L,IL,T,Z,IZ
BLOCK_ROTATIONS
    ;LINE
    dt	0x0F,	0x01,0x01,0x01,0x01,	0x0F,	0x01,0x01,0x01,0x01
    ;SQUARE
    dt	0x03,0x03,  0x03,0x03,	0x03,0x03,  0x03,0x03
    ;IL
    dt	0x04,0x07,  0x03,0x02,0x02, 0x07,0x01,	0x01,0x01,0x03
    ;L
    dt	0x07,0x04,	0x03,0x01,0x01,	0x01,0x07,  0x02,0x02,0x03
    ;T
    dt	0x02,0x07,	0x02,0x03,0x02,	0x07,0x02,	0x01,0x03,0x01
    ;IZ
    dt	0x03,0x06,	0x02,0x03,0x01,	0x03,0x06,	0x02,0x03,0x01
    ;Z
    dt	0x06,0x03,	0x01,0x03,0x02,	0x06,0x03,	0x01,0x03,0x02

BLOCK_SIZES	dt  0x01,0x04,0x01,0x04,    0x02, 0x02, 0x02, 0x02	;LI,S
		dt  0x02,0x03,0x02,0x03,    0x02,0x03,0x02,0x03		;L,IL
		dt  0x02,0x03,0x02,0x03,    0x02,0x03, 0x02,0x03	;T,Z
		dt  0x02,0x03, 0x02,0x03				;IZ
		
BLOCK_WIDTH	dt  0x04,0x01,0x04,0x01,    0x02, 0x02, 0x02, 0x02	;LI,S
		dt  0x03,0x02,0x03,0x02,    0x03,0x02,0x03,0x02		;L,IL
		dt  0x03,0x02,0x03,0x02,    0x03,0x02, 0x03,0x02	;T,Z
		dt  0x03,0x02, 0x03,0x02	
		
BLOCK_STARTS	dt 0x00,0x01,0x05,0x06,	    0x0a, 0x0c, 0x0e, 0x10	;LI,S
		dt 0x12,0x14,0x17,0x19,	    0x1c,0x1e,0x21,0x23		;L,IL
		dt 0x26,0x28,0x2b,0x2d,	    0x30,0x32, 0x35,0x37	;T,Z
		dt 0x3a,0x3c, 0x3f,0x41					;IZ

TITLE_SIZE  equ	.29
GAME_TITLE	;Hardcoded tetris into the screen
		;TETRIS
		dt  0x00,0x80,0xFF,0x80,0x00   ;T
		dt  0xFF,0x91,0x91,0x91,0x91   ;E
		dt  0x00,0x80,0xFF,0x80,0x00   ;T
		dt  0xFF,0x90,0x90,0xFF,0xE7   ;R
		dt  0x00,0x81,0xFF,0x81,0x00   ;I
		dt  0xF1,0x91,0x91,0x91,0x9F   ;S
		    
GET_TITLE
    MOVWF   PIECE_TABLE		;PUT INDEX OUT OF WAY
    MOVLW   HIGH GAME_TITLE	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAG
    MOVF    PIECE_TABLE,W	;RECOVER INDEX
    ADDLW   GAME_TITLE		;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL
		    
GET_SIZE
    MOVWF   PIECE_TABLE		;PUT INDEX OUT OF WAY
    MOVLW   HIGH BLOCK_SIZES	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAG
    MOVF    PIECE_TABLE,W	;RECOVER INDEX
    ADDLW   BLOCK_SIZES		;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL

GET_WIDTH
    MOVWF   PIECE_TABLE		;PUT INDEX OUT OF WAY
    MOVLW   HIGH BLOCK_WIDTH	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAG
    MOVF    PIECE_TABLE,W	;RECOVER INDEX
    ADDLW   BLOCK_WIDTH		;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL

GET_PIECE_START
    MOVWF   PIECE_TABLE		;PUT INDEX OUT OF WAY
    MOVLW   HIGH BLOCK_STARTS	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAG
    MOVF    PIECE_TABLE,W	;RECOVER INDEX
    ADDLW   BLOCK_STARTS	;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL
    
GET_PIECE_ROTATION
    MOVLW   HIGH BLOCK_ROTATIONS    ;GET HIGH PART OF TABLE
    MOVWF   PCLATH		    ;SET PAG
    MOVF    PIECE_START,W	    ;RECOVER INDEX
    ADDLW   BLOCK_ROTATIONS	    ;ADD LOW
    BTFSC   STATUS,C		    ;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL

GET_PIECE
    MOVF    PIECE_TYPE,W
    ANDLW   0x1F		;MAX 32
    MOVWF   PIECE_TYPE
    SUBLW   .27
    BTFSS   STATUS,C
    CLRF    PIECE_TYPE
    
    MOVF    PIECE_TYPE,W
    CALL    GET_WIDTH
    MOVWF   PIECE_WIDTH
    
    MOVF    PIECE_TYPE,W
    CALL    GET_SIZE		;SIZE OF PIECE
    MOVWF   PIECE_SIZE
    MOVWF   SIZE_TEMP
    
    MOVF    PIECE_TYPE,W
    CALL    GET_PIECE_START	;WHERE IT STARTS
    MOVWF   PIECE_START		
    
    
    MOVLW   PIECE_0
    MOVWF   FSR
    
    GET_PIECE_LOOP
	CALL	GET_PIECE_ROTATION
	MOVWF	INDF
	INCF	FSR,F
	INCF	PIECE_START,F
	DECFSZ	SIZE_TEMP,F
	GOTO	GET_PIECE_LOOP
	
    RETLW   0x00
    
PRINT_PIECE	
    MOVF    PIECE_SIZE,W
    MOVWF   SIZE_TEMP
    PRINT_PIECE_LOOP
	;RECOVER CURRENT PIECE INTO PIECE_TEMP
	MOVLW	PIECE_0-1	;REMOVE 1 FROM MEMORY START
	ADDWF	SIZE_TEMP,W	;SIZE 0 IS 1
	MOVWF	FSR
	MOVF	INDF,W
	MOVWF	PIECE_TEMP
	
	;MOVE TO MEMORY WHERE NEEDED
	MOVF	LAST_POS_Y,W
	ADDWF	SIZE_TEMP,W
	MOVWF	PIECE_INTER
	RLF	PIECE_INTER,W
	ADDLW	B0-2
	MOVWF	FSR
	MOVF	PIECE_TEMP,W
	BTFSC	FSR,1
	CALL	REVERSE_BYTE
	BTFSS	OP_REG,0	;if bit 0
	IORWF	INDF,F		;INSTEAD of moving we inclusive or them
				;Collisions are check at other place
	BTFSC	OP_REG,0
	XORWF	INDF,F		;So if we XOR with an already placed piece it 
				;gets removed
	
	DECFSZ	SIZE_TEMP,F
	GOTO	PRINT_PIECE_LOOP
    RETURN

;Piece interactions on collision map
COLLISION_PIECE	
    MOVF    PIECE_SIZE,W
    MOVWF   SIZE_TEMP
    COLLISION_PIECE_LOOP
	;RECOVER CURRENT PIECE INTO PIECE_TEMP
	MOVLW	PIECE_0-1	;REMOVE 1 FROM MEMORY START
	ADDWF	SIZE_TEMP,W	;SIZE 0 IS 1
	MOVWF	FSR
	MOVF	INDF,W
	MOVWF	PIECE_TEMP
	
	;MOVE TO MEMORY WHERE NEEDED
	MOVF	LAST_POS_Y,W
	ADDWF	SIZE_TEMP,W
	ADDLW	BANK1+B0-1
	MOVWF	FSR
	MOVF	PIECE_TEMP,W	
	BTFSC	OP_REG,0	;if bit not 0
	GOTO	COLLISION_CHECK	;go to collision check
	;COLLISION ADD
	IORWF	INDF,F		;INSTEAD of moving we inclusive or them
	GOTO	COLLISON_END
	COLLISION_CHECK
	ANDWF	INDF,W		;AND to check for collision
				;gets removed
	BTFSS	STATUS,Z	; if no collision no bit set, so Z set
	RETLW	0x00		; if collision return NON ZERO, no matter where
        COLLISON_END
	
	DECFSZ	SIZE_TEMP,F
	GOTO	COLLISION_PIECE_LOOP
    RETLW   0xFF

SPAWN_PIECE
    RETURN  ;;TODO
    
UNROTATE
    MOVF    PIECE_TYPE,W
    ANDLW   0x03
    BTFSC   STATUS,Z	    ; i need to reset to 0, otherwise if 0 is clear
    GOTO    UNROTATE_RESET  ;just add 1
    
    DECF    PIECE_TYPE,F    ;
    GOTO    ROTATE_GET
    
    UNROTATE_RESET
    MOVF    PIECE_TYPE,W    ;Get the number and and it with all but 2 lowest
    XORLW   0x03	    ;Put back where it came from
    MOVWF   PIECE_TYPE
    GOTO    ROTATE_GET
    
ROTATE	
    MOVF    PIECE_TYPE,W
    ANDLW   0x03
    XORLW   0x03	    ;1 xor 1 is 0, so if all 2 low bits are 1 then
    BTFSC   STATUS,Z	    ; i need to reset to 0, otherwise if 0 is clear
    GOTO    ROTATION_RESET  ;just add 1
    
    INCF    PIECE_TYPE,F    ;
    GOTO    ROTATE_GET
    
    ROTATION_RESET
    MOVF    PIECE_TYPE,W    ;Get the number and and it with all but 2 lowest
    ANDLW   0xFC	    ;Put back where it came from
    MOVWF   PIECE_TYPE
    
    ROTATE_GET
    CALL    GET_PIECE
    
    ;MOVE TO POSITION
    MOVF    LAST_POS_X,W
    BTFSC   STATUS,Z	    ;IF NO OFFSET
    RETLW   0x00
    ;IF OFFSET
    MOVWF   PIECE_TEMP
    CLRF    LAST_POS_X
    ROTATION_POS_RESET
	CALL	LEFT
	DECFSZ	PIECE_TEMP,F
	GOTO	ROTATION_POS_RESET
    
    RETLW   0x00
    
RIGHT	
    MOVF    LAST_POS_X,F
    BTFSC   STATUS,Z
    RETLW   0xFF
    DECF    LAST_POS_X,F
    MOVF    PIECE_SIZE,W
    MOVWF   SIZE_TEMP
    RIGHT_LOOP
	MOVLW	BANK1+PIECE_0-1
	ADDWF	SIZE_TEMP,W
	MOVWF	FSR
	RRF	INDF,F
	DECFSZ	SIZE_TEMP,F
	GOTO	RIGHT_LOOP
    RETLW   0x00
    
DOWN
    MOVF    LAST_POS_Y,F
    BTFSC   STATUS,Z
    RETLW   0xFF
    DECF    LAST_POS_Y,F
    RETLW   0x00
UP	
    INCF    LAST_POS_Y,F
    RETLW   0x00
LEFT
    MOVLW   .7
    MOVWF   SIZE_TEMP
    MOVF    PIECE_WIDTH,W
    ADDWF   LAST_POS_X,W
    SUBWF   SIZE_TEMP,W
    BTFSS   STATUS,C
    RETLW   0xFF
    
    INCF    LAST_POS_X,F
    MOVF    PIECE_SIZE,W
    MOVWF   SIZE_TEMP
    LEFT_LOOP
	MOVLW	BANK1+PIECE_0-1
	ADDWF	SIZE_TEMP,W
	MOVWF	FSR
	RLF	INDF,F
	DECFSZ	SIZE_TEMP,F
	GOTO	LEFT_LOOP
    RETLW   0x00

CHECK_BUTTON
    MOVWF   PIECE_TEMP
    MOVF    TEMP_STATE,W
    ANDWF   PIECE_TEMP,W
    BTFSC   STATUS,Z
    RETLW   0x00
    MOVWF   TEMP_REG
    MOVF    LAST_STATE,W
    ANDWF   PIECE_TEMP,W
    XORWF   TEMP_REG,W
    BTFSS   STATUS,Z
    RETLW   0xFF
    RETLW   0x00
    
SET_PIECE
    ;SET COLLISION UNTIL DELETED
    BCF	    OP_REG,0
    CALL    COLLISION_PIECE
    
    ;GO BACK TO BANK 0 AND SET PIECE PERMANENTLY ON SCREEN
    BCF	    STATUS,RP1		    
    BCF	    STATUS,RP0
    CALL    PRINT_PIECE
    
    ;CHECK IF ANY ROWS ARE COMPLETED
    BCF	    STATUS,RP1		    
    BSF	    STATUS,RP0
    
    GOTO	CHECK_ROWS
    RETURN_CHECK_ROWS
    
    ;GET NEXT PIECE
    CALL    RANDOM
    MOVWF   PIECE_TYPE
    CALL    GET_PIECE
    ;RESET BACK TO WHERE WE STARTED
    BCF	    STATUS,RP1		    
    BSF	    STATUS,RP0
    BSF	    OP_REG,0
    RETLW   0x00

CHECK_ROWS    
    MOVLW   PLAYABLE_COLS
    MOVWF   CHECK_TEMP
    CHECK_ROWS_LOOP
	MOVF	CHECK_TEMP,W
	ADDLW	BANK1+B0
	MOVWF	FSR
	MOVLW	0xFF
	XORWF	INDF,W
	BTFSC	STATUS,0
	GOTO	CLEAR_COLLISION
	RETURN_CLEAR_COLLISION
	INCF	FSR,F
	DECFSZ	CHECK_TEMP,F
	GOTO	CHECK_ROWS_LOOP
    GOTO    RETURN_CHECK_ROWS
    
CLEAR_COLLISION
    MOVF    CHECK_TEMP,W
    MOVWF   CLEAR_INDX
    
    MOVLW   PLAYABLE_COLS
    MOVWF   CLEAR_TEMP
    MOVF    CHECK_TEMP,W
    SUBWF   CLEAR_TEMP,F    ;PLAYABLE_COLS - current position, to loop from down up
    CLEAR_COLLISION_LOOP
	MOVF	CLEAR_INDX,W	;GET CURRENT POSITION
	ADDLW	BANK1+B0+0x01	;GET SECOND OVER, ON BANK1
	MOVWF	FSR		;SET POINTER
	MOVF	INDF,W		
	MOVWF	CLEAR_T0
	ADDLW	-1		;GO BACK TO ORIGINAL POSITION
	MOVF	CLEAR_T0,W
	MOVWF	INDF
	
	INCF	CLEAR_INDX,F
	DECFSZ	CLEAR_TEMP
	GOTO	CLEAR_COLLISION_LOOP
	
    CLRF    INDF
    GOTO    CLEAR_VISUAL
    
CLEAR_VISUAL
    BCF	STATUS,RP1		    ;FORCE BANK 0
    BCF	STATUS,RP0
    
    MOVF    CHECK_TEMP,W
    MOVWF   CLEAR_INDX
    
    MOVLW   PLAYABLE_COLS
    MOVWF   CLEAR_TEMP
    MOVF    CHECK_TEMP,W
    SUBWF   CLEAR_TEMP,F    ;PLAYABLE_COLS - current position, to loop from down up
    CLEAR_VISUAL_LOOP
	MOVF	CLEAR_INDX,W	;GET CURRENT POSITION
	ADDLW	B0+0x02		;GET SECOND OVER, THE ACTUAL COLUMN
	MOVWF	FSR		;SET POINTER
	MOVF	INDF,W		
	MOVWF	CLEAR_T0
	ADDLW	-2		;GO BACK TO ORIGINAL POSITION
	MOVF	CLEAR_T0,W
	MOVWF	INDF
	
	INCF	CLEAR_INDX,F
	DECFSZ	CLEAR_TEMP
	GOTO	CLEAR_VISUAL_LOOP
	
    CLRF    INDF
    
    BCF	    STATUS,RP1		    ;FORCE BANK 1
    BSF	    STATUS,RP0
    
    GOTO    RETURN_CLEAR_COLLISION

RANDOM       
    MOVF   hiB,W                 ; First, ensure that hiB and lowB aren't
    IORWF  lowB,W               ; all zeros. If they are, NOT hiB to FFh.
    BTFSC  STATUS,Z             ; Otherwise, leave hiB and lowB as is.
    COMF   hiB,F                  
    MOVLW  0x80                 ; We want to XOR hiB.7, hiB.6, hiB.4
    BTFSC  hiB,d'6'             ; and lowB.3 together in W. Rather than
    XORWF  hiB,F                  ; try to line up these bits, we just
    BTFSC  hiB,d'4'             ; check to see whether a bit is a 1. If it
    XORWF  hiB ,F                 ; is, XOR 80h into hiB. If it isn't,
    BTFSC  lowB,d'3'            ; do nothing. When we're done, the
    XORWF  hiB,F                  ; XOR of the 4 bits will be in hiB.7.
    RLF    hiB,W                  ; Move hiB.7 into carry. 
    RLF    lowB,F                   ; Rotate c into lowB.0, lowB.7 into c. 
    RLF    hiB,F                    ; Rotate c into hiB.0. 
    MOVF   lowB,W
    RETURN
	     
RESET_DROP
    MOVLW   LEVEL
    SUBWF   DROP_AMOUNT
    MOVWF   DROP_COUNT
    RETLW   0x00

REVERSE_BYTE
    MOVWF   REVERSE_TEMP
    MOVLW   0x08
    MOVWF   REVERSE_COUNT
    REVERSE_LOOP
	RRF	    REVERSE_TEMP,F
	RLF	    REVERSE_RET,F
	DECFSZ  REVERSE_COUNT,F
	GOTO REVERSE_LOOP
    MOVF    REVERSE_RET,W
    RETURN
    
    
        
MAIN_PROG CODE                      ; let linker place main program

START
    BANKSEL ANSEL
    CLRF    ANSEL
    CLRF    ANSELH
    BANKSEL TRISC		    ; GOTO BANK
    BCF	TRISC,RC6	
    BCF	TRISC,RC7		    ; SET PINRC7 AS OUTPUT
    MOVLW   0xF0
    MOVWF   TRISB
    BANKSEL PORTC		    ; GOTO BANK
    BSF	    PORTC,RC6
    
    
    BANKSEL OSCCON		    ; OSCILATOR CONFIG
    BSF	OSCCON,IRCF2
    BSF	OSCCON,IRCF1
    BCF	OSCCON,IRCF0		    ; SET OSCILATOR TO 4MHZ
    
    
    CLRF    PIECE_0
    CLRF    PIECE_1
    CLRF    PIECE_2
    CLRF    PIECE_3
    
    BANKSEL OSCCON
    BCF	    OSCCON,SCS
    WAIT_START_UP
	BTFSS	OSCCON,OSTS
	GOTO	WAIT_START_UP
	
    BANKSEL PORTC
    
    BSF PORTC,RC7		    ; SET OUTPUT HIGH
    
    MOVLW   SIZE_COL		    ; LOAD COUNTER TO ACUM
    MOVWF   CURRENT_COLUMN	    ; ACUM TO RAM
    
    BCF	    STATUS,IRP		    ; INDIRECT BANK 0,1
    MOVLW   ARRAY_START			    ; GET START POSITION OF COLUMNS
    MOVWF   FSR			    ; INDIRECT ADDRESSING TO START
    
    ;Initialize colors
    INITIALIZE			    ; LOOP TO SET RAM
	MOVLW	0x00		    ; COLUMNS ON
	MOVWF	INDF		    ; FROM ACUM TO INDF COLUMNS ON AND OFF
	INCF	FSR,F		    ; INCREMENT INDIRECT TO INDIRECT
	
	MOVLW	0x01
	MOVWF	INDF		    ; FROM ACUM TO INDF	COLOR OF COLUMN
	INCF	FSR,F		    ; INCREMENT INDIRECT TO INDIRECT
	
	DECFSZ	CURRENT_COLUMN,F    ; DECREASE RAM COUNTER TO SELF
	GOTO	INITIALIZE
	
    ;Initialize logic
    BCF	STATUS,RP1		    ;FORCE BANK 1
    BSF	STATUS,RP0
    
    MOVLW   BANK1+ARRAY_START			    ; GET START POSITION OF COLUMNS
    MOVWF   FSR			    ; INDIRECT ADDRESSING TO START
    
    MOVLW   SIZE_COL*2		    ; LOAD COUNTER TO ACUM
    MOVWF   CURRENT_COLUMN	    ; ACUM TO RAM
    
    INITIALIZE_SECOND			    ; LOOP TO SET RAM
	MOVLW	0x81
	MOVWF	INDF		    ; FROM ACUM TO INDF COLUMNS ON AND OFF
	INCF	FSR,F		    ; INCREMENT INDIRECT TO INDIRECT
	
	DECFSZ	CURRENT_COLUMN,F    ; DECREASE RAM COUNTER TO SELF
	GOTO	INITIALIZE_SECOND

	
    BCF	STATUS,RP1		    ;FORCE BANK 0
    BCF	STATUS,RP0
    
    ;SET VARIABLES TO INITIAL STATE
    MOVLW   0x00
    MOVWF   LAST_POS_X
    MOVLW   PLAYABLE_COLS
    MOVWF   LAST_POS_Y

    ;SET default last state
    MOVLW   0xF0
    MOVWF   LAST_STATE
    ;GENERATE RANDOM PIECE
    MOVLW   0x00
    MOVWF   PIECE_TYPE
    
    ;FINISHED INITIALIZING, START PROGRAM
    START_GAME
	BCF	STATUS,RP1		    ;FORCE BANK 0
	BCF	STATUS,RP0
	MOVLW	TITLE_SIZE
	MOVWF	TEMP_STATE
	
	TITLE_PRINT_LOOP
	    MOVF    TEMP_STATE,W
	    CALL    GET_TITLE
	    MOVWF   LAST_STATE
	    RLF	    TEMP_STATE,W
	    ADDLW   B0
	    MOVWF   FSR
	    MOVF    LAST_STATE,W
	    BTFSC   FSR,1
	    CALL    REVERSE_BYTE
	    MOVWF   INDF
	    INCF    FSR,F
	    CALL    RANDOM
	    MOVWF   INDF
	    DECFSZ  TEMP_STATE,F
	    GOTO    TITLE_PRINT_LOOP
	    
	CALL	PRINT_SCREEN
	MOVF	PORTB,W
	XORLW	0xF0
	BTFSC	STATUS,Z
	GOTO START_GAME
    
    ;Clear Scren
    MOVLW   SIZE_COL		    ; LOAD COUNTER TO ACUM
    MOVWF   CURRENT_COLUMN	    ; ACUM TO RAM
    
    BCF	    STATUS,IRP		    ; INDIRECT BANK 0,1
    MOVLW   ARRAY_START			    ; GET START POSITION OF COLUMNS
    MOVWF   FSR			    ; INDIRECT ADDRESSING TO START
    CLEAR_SCREEN		    ; LOOP TO SET RAM
	CLRF	INDF		    ; FROM ACUM TO INDF COLUMNS ON AND OFF
	INCF	FSR,F		    ; INCREMENT INDIRECT TO INDIRECT
	MOVLW	0x01
	MOVWF	INDF
	INCF	FSR,F		    ; INCREMENT INDIRECT TO INDIRECT
	
	DECFSZ	CURRENT_COLUMN,F    ; DECREASE RAM COUNTER TO SELF
	GOTO	CLEAR_SCREEN
	
    BCF	STATUS,RP1		    ;FORCE BANK 0
    BCF	STATUS,RP0
    
    CALL    GET_PIECE
    BCF	    OP_REG,0
    CALL    PRINT_PIECE
    ;MAIN LOOP
    LOGIC_LOOP
	BSF	PORTC,RC6	   
	BCF	PORTC,RC6
	
	;SCREEN SET
	BCF	STATUS,RP1		    ;FORCE BANK 0
	BCF	STATUS,RP0
	CALL	PRINT_SCREEN
	
	;READ BUTTONS BEFORE LEAVING BANK 0
	MOVF	PORTB,W
	XORLW	0xF0			    ;RC7,RC6,RC5,RC4
	MOVWF	TEMP_STATE
	BSF	OP_REG,0		    ;BEFORE ANY CHANGE ERASE OLD PIECE
	CALL	PRINT_PIECE
	
	;CHANGE BANK 1
	MOVF	TEMP_STATE,W
	BCF	STATUS,RP1		
	BSF	STATUS,RP0
	MOVWF	TEMP_STATE
	
	
	BSF	OP_REG,0		    ;COLLISION PIECE CHECK COLLISION
	
	;BUTTON MANAGMENT
	
    ;ROTATION BUTTON
	MOVLW	0x80
	CALL	CHECK_BUTTON
	XORLW	0xFF
	BTFSS	STATUS,Z
	GOTO	BRC6
	;REMEMBER POSITION BECAUSE WITH ROTATION MAY CHANGE BECAUSE OF WIDTH
	CALL	RESET_DROP	;SET TIMER TO 0
	MOVF	LAST_POS_X,W	;STORE TEMP THE X POSTION BECAUSE WIDTH CHANGE
	MOVWF	ROTATION_T
	CALL	ROTATE

    ;ROTATION COLLISION DETECTION
	
	;CALL	COLLISION_PIECE
	;XORLW	0xFF
	;BTFSS	STATUS,Z
	;GOTO	BRC6
	;IF ROTATION UNSUCSESSFUL
	;MOVF	ROTATION_T,W
	;MOVWF	LAST_POS_X
	;CALL	UNROTATE
	
	
    BRC6
    ;RIGHT BUTTON
	MOVLW	0x40
	CALL	CHECK_BUTTON
	XORLW	0xFF
	BTFSS	STATUS,Z
	GOTO	BRC5
	CALL	RIGHT
	
    ;COLLISION DETECTION
    
	CALL	COLLISION_PIECE
	XORLW	0xFF
	BTFSC	STATUS,Z    ;INVERSED LOGIC, JUST WHEN FAILS CHECKS NO JUMP
	GOTO	BEND
	CALL	LEFT
	
    BRC5
    ;DOWN BUTTON
	MOVLW	0x20
	CALL	CHECK_BUTTON
	XORLW	0xFF
	BTFSS	STATUS,Z
	GOTO	BRC4
	CALL	DOWN		    ;RETURNS 0xFF at bottom,Z=0

    ;ROTATION COLLISION DETECTION
    
	XORLW	0xFF
	BTFSC	STATUS,Z	    ;execute if Z=1
	GOTO	SET_PIECE_DOWN
	;CALL	COLLISION_PIECE	    ;RETURNS 0xFF at collision
	;XORLW	0xFF
	;BTFSS	STATUS,Z	    ;execute if Z=1
	;GOTO	BRC4
    SET_PIECE_DOWN
	;CALL	SET_PIECE
	
    BRC4
    ;LEFT BUTTON
	MOVLW	0x10
	CALL	CHECK_BUTTON
	XORLW	0xFF
	BTFSS	STATUS,Z
	GOTO	BEND
	CALL	LEFT

    ;COLLISION DETECTION
    
	CALL	COLLISION_PIECE
	XORLW	0xFF
	BTFSC	STATUS,Z    ;INVERSED LOGIC, JUST WHEN FAILS CHECKS NO JUMP
	GOTO	BEND
	CALL	RIGHT
	
    BEND
	
;	;GLOBAL COUNTER PULLING DOWN PIECES
;	DECFSZ	DROP_COUNT
;	GOTO	END_DROP_PIECE
;	
;	;DOWN BUTTON CODE
;	CALL	DOWN		    ;RETURNS 0xFF at bottom,Z=0
;	BTFSC	STATUS,Z	    ;execute if Z=1
;	CALL	COLLISION_PIECE	    ;RETURNS 0xFF at collision
;	BTFSC	STATUS,Z	    ;execute if Z=1
;	GOTO	BRC4
;	CALL	UP
;	CALL	SET_PIECE
;	
;	
;	END_DROP_PIECE
;	
	
	BCF	STATUS,RP1		    ;FORCE BANK 0
	BCF	STATUS,RP0
	
	BCF	OP_REG,0
	CALL	PRINT_PIECE
	
	BCF	STATUS,RP1		    ;FORCE BANK 1
	BSF	STATUS,RP0
	
	;DEBUG
	MOVF	TEMP_STATE,W
	MOVWF	B30
	MOVF	LAST_STATE,W
	CALL	REVERSE_BYTE
	MOVWF	B29
	;END DEBUG
	
	END_LOGIC
	MOVF	TEMP_STATE,W
	MOVWF	LAST_STATE
	GOTO LOGIC_LOOP
;WHEN LOST
LOST_GAME
GOTO	START_GAME

END                                                   