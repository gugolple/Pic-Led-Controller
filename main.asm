;Copyright (C) 2019 Gugolple

;This program is free software; you can redistribute it and/or
;modify it under the terms of the GNU General Public License
;as published by the Free Software Foundation; either version 2
;of the License, or (at your option) any later version.

;This program is distributed in the hope that it will be useful,
;but WITHOUT ANY WARRANTY; without even the implied warranty of
;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;GNU General Public License for more details.

;You should have received a copy of the GNU General Public License
;along with this program; if not, write to the Free Software
;Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
    
    
    
; TODO INSERT CONFIG CODE HERE USING CONFIG BITS GENERATOR
#include <p16f690.inc>
    __config (_HS_OSC & _WDT_OFF & _PWRTE_OFF & _MCLRE_OFF & _CP_OFF & _CPD_OFF & _BOR_OFF & _IESO_OFF & _FCMEN_ON)
    
RES_VECT  CODE    0x0000            ; processor reset vector
    CLRF    INTCON		    ; disable interrupts
    GOTO    START                   ; go to beginning of program

Int_Handler CODE    0x0004
    RETFIE

PATTERN equ B'00000001'
SIZE_COL    equ .32
SIZE_B	    equ .8
MAX_COLORS  equ	0x0F		    ;0-15 = 16 colors MASQUING LOGIC
ARRAY_START	equ 0x20
;SECTION JUST USED WHEN PRINTING
;MAY BE REUSED ONLY FOR TEMPORAL USE
COLUMN_INDEX	equ 0x60
CURRENT_COLUMN	equ 0x61
CURRENT_COLUMN_INDEX	equ 0x62
TABLE_TEMPORAL	equ 0x63
CURRENT_COLOR	equ 0x64
INDEXED_COLOR	equ 0x65
TEMP_COLOR	equ 0x66
DISPLAY_COLOR	equ 0x67
CURRENT_DISPLAY_INDEX	equ 0x68

;REUSE FOR REVERSE
REVERSE_TEMP	equ 0x60
REVERSE_RET	equ 0x61
REVERSE_COUNT	equ 0x62

MAX_ROTATIONS  equ	0x03		    ;0-3 = 4 MAQUING ROTATIONS
;REUSE FOR GET_PIECES
PIECE_TEMP	equ 0x60
SIZE_TEMP	equ 0x61
PIECE_START	equ 0x62
PIECE_TABLE	equ 0x63

	
;COMMONS BECAUSE BETWEEN 0x70-0x7F
LAST_STATE  equ 0x7F	;RB4,RB5,RB6,RB7 0xf0
TEMP_STATE  equ	0x7E
LAST_POS_X  equ 0x7D
LAST_POS_Y  equ 0x7C
PIECE_SIZE  equ	0x7B
PIECE_3	    equ	0x7A
PIECE_2	    equ	0x79
PIECE_1	    equ	0x78
PIECE_0	    equ	0x77
PIECE_TYPE  equ	0x76
hiB	    equ 0x75
lowB	    equ 0x74
TEMP_REG    equ	0x73
  
;MAP OF DISPLAY MEMORY, MUST NOT REUSE
    cblock 0x20 ; 0x20 - 0x5F = 64 BYTES 
	B0,C0,B1,C1,B2,C2,B3,C3,B4,C4,B5,C5,B6,C6,B7,C7
	B8,C8,B9,C9,B10,C10,B11,C11,B12,C12,B13,C13,B14,C14,B15,C15
	B16,C16,B17,C17,B18,C18,B19,C19,B20,C20,B21,C21,B22,C22,B23,C23
	B24,C24,B25,C25,B26,C26,B27,C27,B28,C28,B29,C29,B30,C30,B31,C31
    endc

;COLORS_GREEN dt	0x00,0x20,0x00,0x00,0x20,0x20,0x00,0x20,0x10,0x00,0x00,0x10,0x10,0x00,0x20,0x00
;COLORS_RED dt	0x00,0x00,0x20,0x00,0x20,0x00,0x20,0x20,0x00,0x10,0x00,0x10,0x00,0x10,0x10,0x10
;COLORS_BLUE dt	0x00,0x00,0x00,0x20,0x00,0x20,0x20,0x20,0x00,0x00,0x10,0x00,0x10,0x10,0x00,0x20
    
;COLORS In 1/4 of brightness, overheating issues with the leds
COLORS_RED   dt	0x00,0x20,0x10,0x08,0x20,0x10,0x20,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08
COLORS_GREEN dt	0x00,0x20,0x10,0x08,0x00,0x00,0x20,0x10,0x20,0x10,0x20,0x10,0x00,0x00,0x00,0x00
COLORS_BLUE  dt	0x00,0x20,0x10,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x10,0x20,0x20,0x20,0x10
COLOR_BLACK equ 0x00 ; POSITION OF BLACK
 
;LISTA DE BLOQUES
 
;ORDER:	LINE,SQUARE,L,IL,T,Z,IZ
BLOCK_SIZES	dt  0x01,0x04,0x01,0x04,    0x02, 0x02, 0x02, 0x02,	0x03,0x02,0x03,0x02,    0x03,0x02,0x03,0x02,    0x02,0x03,0x02,0x03,    0x02,0x03, 0x02,0x03,   0x02,0x03, 0x02,0x03
BLOCK_STARTS	dt  0x00,0x01,0x05,0x06,    0x0a, 0x0c, 0x0e, 0x10,	0x12,0x15,0x17,0x1a,	0x1c,0x1f,0x21,0x24,	0x26,0x28,0x2b,0x2d,	0x30,0x32, 0x35,0x37,	0x3a,0x3c, 0x3f,0x41
BLOCK_ROTATIONS	dt  0x0F, 0x01,0x01,0x01,0x01, 0x0F, 0x01,0x01,0x01,0x01,  0x03,0x03, 0x03,0x03, 0x03,0x03, 0x03,0x03,	 0x01,0x01,0x03, 0x04,0x07, 0x03,0x02,0x02, 0x07,0x01,	0x02,0x02,0x03, 0x07,0x04, 0x03,0x01,0x01, 0x01,0x07,	0x02,0x07, 0x02,0x03,0x02, 0x07,0x02, 0x01,0x03,0x01,	0x03,0x06, 0x02,0x03,0x01, 0x03,0x06, 0x02,0x03,0x01,	0x06,0x03, 0x01,0x03,0x02, 0x06,0x03, 0x01,0x03,0x02

GET_SIZE
    MOVWF   PIECE_TABLE		;PUT INDEX OUT OF WAY
    MOVLW   HIGH BLOCK_SIZES	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAG
    MOVF    PIECE_TABLE,W	;RECOVER INDEX
    ADDLW   BLOCK_SIZES		;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL

GET_PIECE_START
    MOVWF   PIECE_TABLE		;PUT INDEX OUT OF WAY
    MOVLW   HIGH BLOCK_STARTS	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAG
    MOVF    PIECE_TABLE,W	;RECOVER INDEX
    ADDLW   BLOCK_STARTS	;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL
    
GET_PIECE_ROTATION
    MOVLW   HIGH BLOCK_ROTATIONS    ;GET HIGH PART OF TABLE
    MOVWF   PCLATH		    ;SET PAG
    MOVF    PIECE_START,W	    ;RECOVER INDEX
    ADDLW   BLOCK_ROTATIONS	    ;ADD LOW
    BTFSC   STATUS,C		    ;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL

GET_PIECE
    ANDLW   0x1F		;MAX 32
    MOVWF   PIECE_TEMP		;ACTUAL PIECE I WANT, ROTATION INCLUDED
    SUBLW   .28
    BTFSC   STATUS,C
    MOVF    PIECE_TEMP,W
    
    CALL    GET_SIZE		;SIZE OF PIECE
    MOVWF   PIECE_SIZE
    MOVWF   SIZE_TEMP
    
    MOVF    PIECE_TEMP,W
    CALL    GET_PIECE_START	;WHERE IT STARTS
    MOVWF   PIECE_START		
    
    MOVLW   PIECE_0
    MOVWF   FSR
    
    GET_PIECE_LOOP
	CALL	GET_PIECE_ROTATION
	MOVWF	INDF
	INCF	FSR,F
	INCF	PIECE_START,F
	DECFSZ	SIZE_TEMP,F
	GOTO	GET_PIECE_LOOP
	
    RETLW   0x00
    
ROTATE	RETURN
LEFT	
    DECF    PIECE_TYPE,F
    RETURN
DOWN	RETURN
RIGHT
    INCF    PIECE_TYPE,F
    RETURN

PRINT_PIECE	
    MOVF    PIECE_TYPE,W
    MOVF    LAST_POS_Y,W
    
    MOVF    PIECE_SIZE,W
    MOVWF   SIZE_TEMP
    PRINT_PIECE_LOOP
	;RECOVER CURRENT PIECE INTO PIECE_TEMP
	MOVLW	PIECE_0-1	;REMOVE 1 FROM MEMORY
	ADDWF	SIZE_TEMP,W	;SIZE 0 IS 1
	MOVWF	FSR
	MOVF	INDF,W
	MOVWF	PIECE_TEMP
	;MOVE TO MEMORY WHERE NEEDED
	MOVF	LAST_POS_Y,W
	ADDWF	SIZE_TEMP,W
	MOVWF	FSR
	MOVF	PIECE_TEMP,W
	BTFSC	FSR,0
	CALL	REVERSE_BYTE
	MOVWF	INDF
	
	DECFSZ	SIZE_TEMP,F
	GOTO	PRINT_PIECE_LOOP
    RETURN
RANDOM       MOVF   hiB,W                 ; First, ensure that hiB and lowB aren't
             IORWF  lowB,W               ; all zeros. If they are, NOT hiB to FFh.
             BTFSC  STATUS,Z             ; Otherwise, leave hiB and lowB as is.
             COMF   hiB,F                  
             MOVLW  0x80                 ; We want to XOR hiB.7, hiB.6, hiB.4
             BTFSC  hiB,d'6'             ; and lowB.3 together in W. Rather than
             XORWF  hiB,F                  ; try to line up these bits, we just
             BTFSC  hiB,d'4'             ; check to see whether a bit is a 1. If it
             XORWF  hiB ,F                 ; is, XOR 80h into hiB. If it isn't,
             BTFSC  lowB,d'3'            ; do nothing. When we're done, the
             XORWF  hiB,F                  ; XOR of the 4 bits will be in hiB.7.
             RLF    hiB,W                  ; Move hiB.7 into carry. 
             RLF    lowB,F                   ; Rotate c into lowB.0, lowB.7 into c. 
             RLF    hiB,F                    ; Rotate c into hiB.0. 
	     MOVF   lowB,W
             RETURN
	     
REVERSE_BYTE
    MOVWF   REVERSE_TEMP
    MOVLW   0x08
    MOVWF   REVERSE_COUNT
    REVERSE_LOOP
	RRF	    REVERSE_TEMP,F
	RLF	    REVERSE_RET,F
	DECFSZ  REVERSE_COUNT,F
	GOTO REVERSE_LOOP
    MOVF    REVERSE_RET,W
    RETURN
    
    
GET_GREEN
    MOVWF   TABLE_TEMPORAL	;PUT INDEX OUT OF WAY
    MOVLW   HIGH COLORS_GREEN	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAG
    MOVF    TABLE_TEMPORAL,W	;RECOVER INDEX
    ANDLW   MAX_COLORS		;GET MAX 16
    ADDLW   COLORS_GREEN	;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL
GET_RED
    MOVWF   TABLE_TEMPORAL	;PUT INDEX OUT OF WAY
    MOVLW   HIGH COLORS_RED	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAGE
    MOVF    TABLE_TEMPORAL,W	;RECOVER INDEX
    ANDLW   MAX_COLORS		;GET MAX 16
    ADDLW   COLORS_RED		;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL
GET_BLUE
    MOVWF   TABLE_TEMPORAL	;PUT INDEX OUT OF WAY
    MOVLW   HIGH COLORS_BLUE	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAGE
    MOVF    TABLE_TEMPORAL,W	;RECOVER INDEX
    ANDLW   MAX_COLORS		;GET MAX 16
    ADDLW   COLORS_BLUE		;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL
    
    
PRINT_SCREEN			    ; Only works on bank 0 or 2
    BSF	PORTC,RC7		    ; SET OUTPUT HIGH, START RESET
    MOVLW   .80
    MOVWF   CURRENT_COLUMN
    SEND_RESET_HIGH			    ; Reset >50 microseconds
	DECFSZ	CURRENT_COLUMN,F	    ; Tnstruction 0.4 * 3 (AMOUNT INST) 10MHz
	GOTO SEND_RESET_HIGH		    ;  = 1.2 microseconds
	
    BCF	PORTC,RC7		    ; SET OUTPUT LOW, START RESET
    MOVLW   .80
    MOVWF   CURRENT_COLUMN
    SEND_RESET			    ; Reset >50 microseconds
	DECFSZ	CURRENT_COLUMN,F	    ; Tnstruction 0.4 * 3 (AMOUNT INST) 10MHz
	GOTO SEND_RESET		    ;  = 1.2 microseconds
	
	
    ;BSF	PORTC,RC6
		NOP
		NOP
		NOP
		NOP
		NOP
		NOP
		NOP
		NOP
		NOP
		NOP
		NOP
		NOP	   
    ;BCF	PORTC,RC6
	
	
    MOVLW   ARRAY_START		    ; START INDIRECT ACCES TO FIRST WORD
    MOVWF   FSR			    
    
    MOVLW   SIZE_COL
    MOVWF   COLUMN_INDEX
    COLUMN_LOOP
	MOVLW	SIZE_B
	MOVWF	CURRENT_COLUMN_INDEX
	
	MOVF	INDF,W
	MOVWF	CURRENT_COLUMN	    ;LED PATTERN
	INCF	FSR,F
	
	MOVF	INDF,W
	MOVWF	CURRENT_COLOR	    ;LED COLOR
	INCF	FSR,F
	
	COLUMN_BIT
	MOVF	CURRENT_COLOR,W
	BTFSS   CURRENT_COLUMN,7	; IF CURRENT POSITIOS IS ON
	MOVLW   COLOR_BLACK
	MOVWF   TEMP_COLOR
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    ;GREEN
	    CALL    GET_GREEN
	    MOVWF   DISPLAY_COLOR
	    MOVLW   SIZE_B
	    MOVWF   CURRENT_DISPLAY_INDEX
	    GREEN_LOOP
		BTFSS   DISPLAY_COLOR,7	; IF 0 HIGHEST BIT
		GOTO    LOOP_GREEN_SHORT	; GO TO SHORT
		BSF	    PORTC,RC7		; LONG, 1
		NOP
		NOP
		NOP
		BCF	    PORTC,RC7
		GOTO    LOOP_GREEN_END
		LOOP_GREEN_SHORT
		BSF	    PORTC,RC7		; SHORT, 0
		BCF	    PORTC,RC7
		LOOP_GREEN_END
		RLF	DISPLAY_COLOR,F
		DECFSZ  CURRENT_DISPLAY_INDEX,F
		GOTO GREEN_LOOP
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
		
	    ;RED
	    MOVF    TEMP_COLOR,W
	    CALL    GET_RED
	    MOVWF   DISPLAY_COLOR
	    MOVLW   SIZE_B
	    MOVWF   CURRENT_DISPLAY_INDEX
	    RED_LOOP
		BTFSS   DISPLAY_COLOR,7	; IF 0 HIGHEST BIT
		GOTO    LOOP_RED_SHORT	; GO TO SHORT
		BSF	    PORTC,RC7		; LONG, 1
		NOP
		NOP
		NOP
		BCF	    PORTC,RC7
		GOTO    LOOP_RED_END
		LOOP_RED_SHORT
		BSF	    PORTC,RC7		; SHORT, 0
		BCF	    PORTC,RC7
		LOOP_RED_END
		RLF	DISPLAY_COLOR,F
		DECFSZ  CURRENT_DISPLAY_INDEX,F
		GOTO RED_LOOP
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
		
	    ;BLUE
	    MOVF    TEMP_COLOR,W
	    CALL    GET_BLUE
	    MOVWF   DISPLAY_COLOR
	    MOVLW   SIZE_B
	    MOVWF   CURRENT_DISPLAY_INDEX
	    BLUE_LOOP
		BTFSS   DISPLAY_COLOR,7	; IF 0 HIGHEST BIT
		GOTO    LOOP_BLUE_SHORT	; GO TO SHORT
		BSF	    PORTC,RC7		; LONG, 1
		NOP
		NOP
		NOP
		BCF	    PORTC,RC7
		GOTO    LOOP_BLUE_END
		LOOP_BLUE_SHORT
		BSF	    PORTC,RC7		; SHORT, 0
		BCF	    PORTC,RC7
		LOOP_BLUE_END
		RLF	DISPLAY_COLOR,F
		DECFSZ  CURRENT_DISPLAY_INDEX,F
		GOTO BLUE_LOOP
		
	    ;BSF	PORTC,RC6	   
	    ;BCF	PORTC,RC6
	    RLF	CURRENT_COLUMN,F
	    DECFSZ  CURRENT_COLUMN_INDEX,F
	    GOTO COLUMN_BIT

	DECFSZ	COLUMN_INDEX,F
	GOTO	COLUMN_LOOP

    ;BCF	PORTC,RC6
    BSF PORTC,RC7	
    RETURN

    
MAIN_PROG CODE                      ; let linker place main program

START
    BANKSEL ANSEL
    CLRF    ANSEL
    CLRF    ANSELH
    BANKSEL TRISC		    ; GOTO BANK
    BCF	TRISC,RC6	
    BCF	TRISC,RC7		    ; SET PINRC7 AS OUTPUT
    MOVLW   0xF0
    MOVWF   TRISB
    
    BANKSEL OSCCON
    clrf	OSCCON			; Internal clock to 31KHz & ext clock source
    
    BANKSEL OSCCON		    ; OSCILATOR CONFIG
    BSF	OSCCON,IRCF2
    BSF	OSCCON,IRCF1
    BCF	OSCCON,IRCF0		    ; SET OSCILATOR TO 4MHZ
    
    STABILIZATION
	BTFSS	OSCCON,HTS	    ; JUST WAIT UNTIL FLAG OF STABILIZATION
	GOTO STABILIZATION

	
    BANKSEL PORTC
    
    BSF PORTC,RC7		    ; SET OUTPUT HIGH
    CLRF    LAST_POS_Y
    
    MOVLW   SIZE_COL		    ; LOAD COUNTER TO ACUM
    MOVWF   CURRENT_COLUMN	    ; ACUM TO RAM
    
    BCF	    STATUS,IRP		    ; INDIRECT BANK 0,1
    MOVLW   ARRAY_START			    ; GET START POSITION OF COLUMNS
    MOVWF   FSR			    ; INDIRECT ADDRESSING TO START
    
    
    INITIALIZE			    ; LOOP TO SET RAM
	MOVLW	0x00		    ; COLUMNS ON
	MOVWF	INDF		    ; FROM ACUM TO INDF COLUMNS ON AND OFF
	INCF	FSR,F		    ; INCREMENT INDIRECT TO INDIRECT
	
	MOVLW	0x01
	MOVWF	INDF		    ; FROM ACUM TO INDF	COLOR OF COLUMN
	INCF	FSR,F		    ; INCREMENT INDIRECT TO INDIRECT
	
	DECFSZ	CURRENT_COLUMN,F    ; DECREASE RAM COUNTER TO SELF
	GOTO	INITIALIZE

    MOVLW   0x04
    MOVWF   LAST_POS_X
    MOVWF   LAST_POS_Y

    MOVLW   0x00
    MOVWF   PIECE_TYPE
    
    CLRF    B0
    CLRF    B1
    CLRF    B2
    CLRF    B3
    
    LOGIC_LOOP
	BSF	PORTC,RC6	   
	BCF	PORTC,RC6
	
	MOVLW	0x0F
	MOVWF	B31
	CALL	RANDOM
	MOVWF	C31

	CALL	PRINT_SCREEN
	
	MOVF	PORTB,W
	MOVWF	TEMP_STATE
	
	ANDLW	0x80		;CHECK RC7
        MOVWF	TEMP_REG
	MOVF	LAST_STATE,W
	ANDLW	0x80
	XORWF	TEMP_REG,W
	;BTFSC	STATUS,Z
	;CALL	ROTATE
	
	MOVF	TEMP_STATE,W
	ANDLW	0x40		;CHECK RC6
        MOVWF	TEMP_REG
	MOVF	LAST_STATE,W
	ANDLW	0x40
	XORWF	TEMP_REG,W
	;BTFSC	STATUS,Z
	;CALL	LEFT
	
	MOVF	TEMP_STATE,W
	ANDLW	0x20		;CHECK RC5
        MOVWF	TEMP_REG
	MOVF	LAST_STATE,W
	ANDLW	0x20
	XORWF	TEMP_REG,W
	;BTFSC	STATUS,Z
	;CALL	DOWN
	
	MOVF	TEMP_STATE,W
	ANDLW	0x10		;CHECK RC4
        MOVWF	TEMP_REG
	MOVF	LAST_STATE,W
	ANDLW	0x10
	XORWF	TEMP_REG,W
	BTFSC	STATUS,Z
	INCF	PIECE_TYPE
	;CALL	RIGHT
	
	;CALL	PRINT_PIECE
	
	CALL	GET_PIECE
	MOVF	PIECE_0,W
	CALL	REVERSE_BYTE
	MOVWF	B0
	MOVF	PIECE_1,W
	MOVWF	B1
	MOVF	PIECE_2,W
	CALL	REVERSE_BYTE
	MOVWF	B2
	MOVF	PIECE_3,W
	MOVWF	B3
	
	END_LOGIC
	MOVF	TEMP_STATE,W
	MOVWF	LAST_STATE
	GOTO LOGIC_LOOP
END