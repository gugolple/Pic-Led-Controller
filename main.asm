;Copyright (C) 2019 Gugolple

;This program is free software; you can redistribute it and/or
;modify it under the terms of the GNU General Public License
;as published by the Free Software Foundation; either version 2
;of the License, or (at your option) any later version.

;This program is distributed in the hope that it will be useful,
;but WITHOUT ANY WARRANTY; without even the implied warranty of
;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;GNU General Public License for more details.

;You should have received a copy of the GNU General Public License
;along with this program; if not, write to the Free Software
;Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
    
    
    
; TODO INSERT CONFIG CODE HERE USING CONFIG BITS GENERATOR
#include <p16f690.inc>
    __config (_HS_OSC & _WDT_OFF & _PWRTE_ON & _MCLRE_OFF & _CP_OFF & _CPD_OFF & _BOR_OFF & _IESO_OFF & _FCMEN_ON)
    
RES_VECT  CODE    0x0000            ; processor reset vector
    CLRF    INTCON		    ; disable interrupts
    GOTO    START                   ; go to beginning of program

Int_Handler CODE    0x0004
    RETFIE

;CONSTANTS
PATTERN equ B'00000001'
SIZE_COL    equ .32
SIZE_B	    equ .8
MAX_COLORS  equ	0x0F		    ;0-15 = 16 colors MASQUING LOGIC
ARRAY_START	equ 0x20
;SECTION JUST USED WHEN PRINTING
;MAY BE REUSED ONLY FOR TEMPORAL USE
COLUMN_INDEX	equ 0x60
CURRENT_COLUMN	equ 0x61
CURRENT_COLUMN_INDEX	equ 0x62
TABLE_TEMPORAL	equ 0x63
CURRENT_COLOR	equ 0x64
INDEXED_COLOR	equ 0x65
TEMP_COLOR	equ 0x66
DISPLAY_COLOR	equ 0x67
CURRENT_DISPLAY_INDEX	equ 0x68

;REUSE FOR REVERSE
REVERSE_TEMP	equ 0x60
REVERSE_RET	equ 0x61
REVERSE_COUNT	equ 0x62

MAX_ROTATIONS  equ	0x03		    ;0-3 = 4 MAQUING ROTATIONS
;REUSE FOR GET_PIECES
PIECE_TEMP	equ 0x63
SIZE_TEMP	equ 0x64
PIECE_START	equ 0x65
PIECE_TABLE	equ 0x66
PIECE_INTER	equ 0x67

	
;COMMONS BECAUSE BETWEEN 0x70-0x7F
LAST_STATE  equ 0x7F	;RB4,RB5,RB6,RB7 0xf0
TEMP_STATE  equ	0x7E
LAST_POS_X  equ 0x7D
LAST_POS_Y  equ 0x7C
PIECE_SIZE  equ	0x7B
PIECE_3	    equ	0x7A
PIECE_2	    equ	0x79
PIECE_1	    equ	0x78
PIECE_0	    equ	0x77
PIECE_TYPE  equ	0x76
hiB	    equ 0x75
lowB	    equ 0x74
TEMP_REG    equ	0x73
PRINT_REG   equ	0x72
    
; BANK 1 MAPS, LOGIC ONLY    
  
;MAP OF DISPLAY MEMORY, MUST NOT REUSE
    cblock 0x20 ; 0x20 - 0x5F = 64 BYTES 
	B0,C0,B1,C1,B2,C2,B3,C3,B4,C4,B5,C5,B6,C6,B7,C7
	B8,C8,B9,C9,B10,C10,B11,C11,B12,C12,B13,C13,B14,C14,B15,C15
	B16,C16,B17,C17,B18,C18,B19,C19,B20,C20,B21,C21,B22,C22,B23,C23
	B24,C24,B25,C25,B26,C26,B27,C27,B28,C28,B29,C29,B30,C30,B31,C31
    endc

;COLORS_GREEN dt	0x00,0x20,0x00,0x00,0x20,0x20,0x00,0x20,0x10,0x00,0x00,0x10,0x10,0x00,0x20,0x00
;COLORS_RED dt	0x00,0x00,0x20,0x00,0x20,0x00,0x20,0x20,0x00,0x10,0x00,0x10,0x00,0x10,0x10,0x10
;COLORS_BLUE dt	0x00,0x00,0x00,0x20,0x00,0x20,0x20,0x20,0x00,0x00,0x10,0x00,0x10,0x10,0x00,0x20
    
;COLORS In 1/4 of brightness, overheating issues with the leds
COLORS_RED   dt	0x00,0x20,0x10,0x08,0x20,0x10,0x20,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08
COLORS_GREEN dt	0x00,0x20,0x10,0x08,0x00,0x00,0x20,0x10,0x20,0x10,0x20,0x10,0x00,0x00,0x00,0x00
COLORS_BLUE  dt	0x00,0x20,0x10,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x10,0x20,0x20,0x20,0x10
COLOR_BLACK equ 0x00 ; POSITION OF BLACK
 
;LISTA DE BLOQUES
 
;ORDER:	LI,S,L,IL,T,Z,IZ
BLOCK_ROTATIONS
    ;LINE
    RETLW 0x0F
    
    RETLW 0x01
    RETLW 0x01
    RETLW 0x01
    RETLW 0x01
    
    RETLW 0x0F
    
    RETLW 0x01
    RETLW 0x01
    RETLW 0x01
    RETLW 0x01
    
    ;SQUARE
    RETLW 0x03
    RETLW 0x03
    
    RETLW 0x03
    RETLW 0x03
    
    RETLW 0x03
    RETLW 0x03
    
    RETLW 0x03
    RETLW 0x03
    
    ;IL
    RETLW 0x04
    RETLW 0x07
    
    RETLW 0x03
    RETLW 0x02
    RETLW 0x02
    
    RETLW 0x07
    RETLW 0x01
    
    RETLW 0x01
    RETLW 0x01
    RETLW 0x03
    
    ;L
    RETLW 0x07
    RETLW 0x04
    
    RETLW 0x03
    RETLW 0x01
    RETLW 0x01
    
    RETLW 0x01
    RETLW 0x07
    
    RETLW 0x02
    RETLW 0x02
    RETLW 0x03
    
    ;T
    RETLW 0x02
    RETLW 0x07
    
    RETLW 0x02
    RETLW 0x03
    RETLW 0x02
    
    RETLW 0x07
    RETLW 0x02
    
    RETLW 0x01
    RETLW 0x03
    RETLW 0x01
    
    ;IZ
    RETLW 0x03
    RETLW 0x06
    
    RETLW 0x02
    RETLW 0x03
    RETLW 0x01
    
    RETLW 0x03
    RETLW 0x06
    
    RETLW 0x02
    RETLW 0x03
    RETLW 0x01
    
    ;Z
    RETLW 0x06
    RETLW 0x03
    
    RETLW 0x01
    RETLW 0x03
    RETLW 0x02
    
    RETLW 0x06
    RETLW 0x03
    
    RETLW 0x01
    RETLW 0x03
    RETLW 0x02

BLOCK_SIZES	dt  0x01,0x04,0x01,0x04,    0x02, 0x02, 0x02, 0x02	;LI,S
		dt  0x02,0x03,0x02,0x03,    0x02,0x03,0x02,0x03		;L,IL
		dt  0x02,0x03,0x02,0x03,    0x02,0x03, 0x02,0x03	;T,Z
		dt  0x02,0x03, 0x02,0x03				;IZ
		
BLOCK_STARTS	dt 0x00,0x01,0x05,0x06,	    0x0a, 0x0c, 0x0e, 0x10	;LI,S
		dt 0x12,0x14,0x17,0x19,	    0x1c,0x1e,0x21,0x23		;L,IL
		dt 0x26,0x28,0x2b,0x2d,	    0x30,0x32, 0x35,0x37	;T,Z
		dt 0x3a,0x3c, 0x3f,0x41					;IZ
;BLOCK_STARTS	dt  0x00,0x01,0x05,0x06,    0x0a, 0x0c, 0x0e, 0x10	;LI,S
;		dt  0x12,0x15,0x17,0x1a,    0x1c,0x1f,0x21,0x24		;L,IL
;		dt  0x26,0x28,0x2b,0x2d,    0x30,0x32, 0x35,0x37	;T,Z
;		dt  0x3a,0x3c, 0x3f,0x41				;IZ
		    
GET_SIZE
    MOVWF   PIECE_TABLE		;PUT INDEX OUT OF WAY
    MOVLW   HIGH BLOCK_SIZES	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAG
    MOVF    PIECE_TABLE,W	;RECOVER INDEX
    ADDLW   BLOCK_SIZES		;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL

GET_PIECE_START
    MOVWF   PIECE_TABLE		;PUT INDEX OUT OF WAY
    MOVLW   HIGH BLOCK_STARTS	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAG
    MOVF    PIECE_TABLE,W	;RECOVER INDEX
    ADDLW   BLOCK_STARTS	;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL
    
GET_PIECE_ROTATION
    MOVLW   HIGH BLOCK_ROTATIONS    ;GET HIGH PART OF TABLE
    MOVWF   PCLATH		    ;SET PAG
    MOVF    PIECE_START,W	    ;RECOVER INDEX
    ADDLW   BLOCK_ROTATIONS	    ;ADD LOW
    BTFSC   STATUS,C		    ;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL

GET_PIECE
    MOVF    PIECE_TYPE,W
    ANDLW   0x1F		;MAX 32
    MOVWF   PIECE_TYPE
    SUBLW   .27
    BTFSS   STATUS,C
    CLRF    PIECE_TYPE
    
    MOVF    PIECE_TYPE,W
    
    CALL    GET_SIZE		;SIZE OF PIECE
    MOVWF   PIECE_SIZE
    MOVWF   SIZE_TEMP
    
    MOVF    PIECE_TYPE,W
    CALL    GET_PIECE_START	;WHERE IT STARTS
    MOVWF   PIECE_START		
    
    MOVLW   PIECE_0
    MOVWF   FSR
    
    GET_PIECE_LOOP
	CALL	GET_PIECE_ROTATION
	MOVWF	INDF
	INCF	FSR,F
	INCF	PIECE_START,F
	DECFSZ	SIZE_TEMP,F
	GOTO	GET_PIECE_LOOP
	
    RETLW   0x00
    
PRINT_PIECE	
    MOVF    PIECE_SIZE,W
    MOVWF   SIZE_TEMP
    PRINT_PIECE_LOOP
	;RECOVER CURRENT PIECE INTO PIECE_TEMP
	MOVLW	PIECE_0-1	;REMOVE 1 FROM MEMORY START
	ADDWF	SIZE_TEMP,W	;SIZE 0 IS 1
	MOVWF	FSR
	MOVF	INDF,W
	MOVWF	PIECE_TEMP
	
	;MOVE TO MEMORY WHERE NEEDED
	MOVF	LAST_POS_Y,W
	ADDWF	SIZE_TEMP,W
	MOVWF	PIECE_INTER
	RLF	PIECE_INTER,W
	ADDLW	B0
	MOVWF	FSR
	MOVF	PIECE_TEMP,W
	BTFSC	FSR,1
	CALL	REVERSE_BYTE
	BTFSS	PRINT_REG,0
	IORWF	INDF,F		;INSTEAD of moving we inclusive or them
				;Collisions are check at other place
	BTFSC	PRINT_REG,0
	XORWF	INDF,F		;So if we XOR with an already placed piece it 
				;gets removed
	
	DECFSZ	SIZE_TEMP,F
	GOTO	PRINT_PIECE_LOOP
    RETURN
    
ROTATE	
    MOVF    PIECE_TYPE,W
    ANDLW   0x03
    XORLW   0x03	    ;1 xor 1 is 0, so if all 2 low bits are 1 then
    BTFSC   STATUS,Z	    ; i need to reset to 0, otherwise if 0 is clear
    GOTO    ROTATION_RESET  ;just add 1
    
    INCF    PIECE_TYPE,F    ;
    CALL    GET_PIECE
    RETLW   0x00
    
    ROTATION_RESET
    MOVF    PIECE_TYPE,W    ;Get the number and and it with all but 2 lowest
    ANDLW   0xFC	    ;Put back where it came from
    MOVWF   PIECE_TYPE
    CALL    GET_PIECE
    RETLW   0x00
LEFT	
    MOVF    LAST_POS_X,F
    BTFSS   STATUS,Z
    DECF    LAST_POS_X,F
    RETLW   0x00
DOWN	
    RETLW   0x00
RIGHT
    MOVF    LAST_POS_X,W
    XORLW   0x07
    BTFSS   STATUS,Z
    INCF    LAST_POS_X,F
    RETLW   0x00



RANDOM       MOVF   hiB,W                 ; First, ensure that hiB and lowB aren't
             IORWF  lowB,W               ; all zeros. If they are, NOT hiB to FFh.
             BTFSC  STATUS,Z             ; Otherwise, leave hiB and lowB as is.
             COMF   hiB,F                  
             MOVLW  0x80                 ; We want to XOR hiB.7, hiB.6, hiB.4
             BTFSC  hiB,d'6'             ; and lowB.3 together in W. Rather than
             XORWF  hiB,F                  ; try to line up these bits, we just
             BTFSC  hiB,d'4'             ; check to see whether a bit is a 1. If it
             XORWF  hiB ,F                 ; is, XOR 80h into hiB. If it isn't,
             BTFSC  lowB,d'3'            ; do nothing. When we're done, the
             XORWF  hiB,F                  ; XOR of the 4 bits will be in hiB.7.
             RLF    hiB,W                  ; Move hiB.7 into carry. 
             RLF    lowB,F                   ; Rotate c into lowB.0, lowB.7 into c. 
             RLF    hiB,F                    ; Rotate c into hiB.0. 
	     MOVF   lowB,W
             RETURN
	     
REVERSE_BYTE
    MOVWF   REVERSE_TEMP
    MOVLW   0x08
    MOVWF   REVERSE_COUNT
    REVERSE_LOOP
	RRF	    REVERSE_TEMP,F
	RLF	    REVERSE_RET,F
	DECFSZ  REVERSE_COUNT,F
	GOTO REVERSE_LOOP
    MOVF    REVERSE_RET,W
    RETURN
    
    
GET_GREEN
    MOVWF   TABLE_TEMPORAL	;PUT INDEX OUT OF WAY
    MOVLW   HIGH COLORS_GREEN	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAG
    MOVF    TABLE_TEMPORAL,W	;RECOVER INDEX
    ANDLW   MAX_COLORS		;GET MAX 16
    ADDLW   COLORS_GREEN	;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL
GET_RED
    MOVWF   TABLE_TEMPORAL	;PUT INDEX OUT OF WAY
    MOVLW   HIGH COLORS_RED	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAGE
    MOVF    TABLE_TEMPORAL,W	;RECOVER INDEX
    ANDLW   MAX_COLORS		;GET MAX 16
    ADDLW   COLORS_RED		;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL
GET_BLUE
    MOVWF   TABLE_TEMPORAL	;PUT INDEX OUT OF WAY
    MOVLW   HIGH COLORS_BLUE	;GET HIGH PART OF TABLE
    MOVWF   PCLATH		;SET PAGE
    MOVF    TABLE_TEMPORAL,W	;RECOVER INDEX
    ANDLW   MAX_COLORS		;GET MAX 16
    ADDLW   COLORS_BLUE		;ADD LOW
    BTFSC   STATUS,C		;CHECK IF ROLLOVER, 1 MAX, table size 256 (0-255)
    INCF    PCLATH,F
    MOVWF   PCL
    
    
PRINT_SCREEN			    ; Only works on bank 0 or 2
    BCF	STATUS,RP1		    ;FORCE BANK 0
    BCF	STATUS,RP0
    BSF	PORTC,RC7		    ; SET OUTPUT HIGH, START RESET
    MOVLW   .80
    MOVWF   CURRENT_COLUMN
    SEND_RESET_HIGH			    ; Reset >50 microseconds
	DECFSZ	CURRENT_COLUMN,F	    ; Tnstruction 0.4 * 3 (AMOUNT INST) 10MHz
	GOTO SEND_RESET_HIGH		    ;  = 1.2 microseconds
	
    BCF	PORTC,RC7		    ; SET OUTPUT LOW, START RESET
    MOVLW   .80
    MOVWF   CURRENT_COLUMN
    SEND_RESET			    ; Reset >50 microseconds
	DECFSZ	CURRENT_COLUMN,F	    ; Tnstruction 0.4 * 3 (AMOUNT INST) 10MHz
	GOTO SEND_RESET		    ;  = 1.2 microseconds
	
	
    MOVLW   ARRAY_START		    ; START INDIRECT ACCES TO FIRST WORD
    MOVWF   FSR			    
    
    MOVLW   SIZE_COL
    MOVWF   COLUMN_INDEX
    COLUMN_LOOP
	MOVLW	SIZE_B
	MOVWF	CURRENT_COLUMN_INDEX
	
	MOVF	INDF,W
	MOVWF	CURRENT_COLUMN	    ;LED PATTERN
	INCF	FSR,F
	
	MOVF	INDF,W
	MOVWF	CURRENT_COLOR	    ;LED COLOR
	INCF	FSR,F
	
	COLUMN_BIT
	MOVF	CURRENT_COLOR,W
	BTFSS   CURRENT_COLUMN,7	; IF CURRENT POSITIOS IS ON
	MOVLW   COLOR_BLACK
	MOVWF   TEMP_COLOR
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    ;GREEN
	    CALL    GET_GREEN
	    MOVWF   DISPLAY_COLOR
	    MOVLW   SIZE_B
	    MOVWF   CURRENT_DISPLAY_INDEX
	    GREEN_LOOP
		BTFSS   DISPLAY_COLOR,7	; IF 0 HIGHEST BIT
		GOTO    LOOP_GREEN_SHORT	; GO TO SHORT
		BSF	    PORTC,RC7		; LONG, 1
		NOP
		NOP
		BCF	    PORTC,RC7
		GOTO    LOOP_GREEN_END
		LOOP_GREEN_SHORT
		BSF	    PORTC,RC7		; SHORT, 0
		BCF	    PORTC,RC7
		LOOP_GREEN_END
		RLF	DISPLAY_COLOR,F
		DECFSZ  CURRENT_DISPLAY_INDEX,F
		GOTO GREEN_LOOP
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
		
	    ;RED
	    MOVF    TEMP_COLOR,W
	    CALL    GET_RED
	    MOVWF   DISPLAY_COLOR
	    MOVLW   SIZE_B
	    MOVWF   CURRENT_DISPLAY_INDEX
	    RED_LOOP
		BTFSS   DISPLAY_COLOR,7	; IF 0 HIGHEST BIT
		GOTO    LOOP_RED_SHORT	; GO TO SHORT
		BSF	    PORTC,RC7		; LONG, 1
		NOP
		NOP
		BCF	    PORTC,RC7
		GOTO    LOOP_RED_END
		LOOP_RED_SHORT
		BSF	    PORTC,RC7		; SHORT, 0
		BCF	    PORTC,RC7
		LOOP_RED_END
		RLF	DISPLAY_COLOR,F
		DECFSZ  CURRENT_DISPLAY_INDEX,F
		GOTO RED_LOOP
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
	    NOP
		
	    ;BLUE
	    MOVF    TEMP_COLOR,W
	    CALL    GET_BLUE
	    MOVWF   DISPLAY_COLOR
	    MOVLW   SIZE_B
	    MOVWF   CURRENT_DISPLAY_INDEX
	    BLUE_LOOP
		BTFSS   DISPLAY_COLOR,7	; IF 0 HIGHEST BIT
		GOTO    LOOP_BLUE_SHORT	; GO TO SHORT
		BSF	    PORTC,RC7		; LONG, 1
		NOP
		NOP
		BCF	    PORTC,RC7
		GOTO    LOOP_BLUE_END
		LOOP_BLUE_SHORT
		BSF	    PORTC,RC7		; SHORT, 0
		BCF	    PORTC,RC7
		LOOP_BLUE_END
		RLF	DISPLAY_COLOR,F
		DECFSZ  CURRENT_DISPLAY_INDEX,F
		GOTO BLUE_LOOP
		
	    ;BSF	PORTC,RC6	   
	    ;BCF	PORTC,RC6
	    RLF	CURRENT_COLUMN,F
	    DECFSZ  CURRENT_COLUMN_INDEX,F
	    GOTO COLUMN_BIT

	DECFSZ	COLUMN_INDEX,F
	GOTO	COLUMN_LOOP

    ;BCF	PORTC,RC6
    BSF PORTC,RC7	
    RETURN

    
MAIN_PROG CODE                      ; let linker place main program

START
    BANKSEL ANSEL
    CLRF    ANSEL
    CLRF    ANSELH
    BANKSEL TRISC		    ; GOTO BANK
    BCF	TRISC,RC6	
    BCF	TRISC,RC7		    ; SET PINRC7 AS OUTPUT
    MOVLW   0xF0
    MOVWF   TRISB
    BANKSEL PORTC		    ; GOTO BANK
    BSF	    PORTC,RC6
    
    
    BANKSEL OSCCON		    ; OSCILATOR CONFIG
    BSF	OSCCON,IRCF2
    BSF	OSCCON,IRCF1
    BCF	OSCCON,IRCF0		    ; SET OSCILATOR TO 4MHZ
    
    
    
    
    BANKSEL OSCCON
    BCF	    OSCCON,SCS
    WAIT_START_UP
	BTFSS	OSCCON,OSTS
	GOTO	WAIT_START_UP
        
    
    ;STABILIZATION
	;BTFSS	OSCCON,HTS	    ; JUST WAIT UNTIL FLAG OF STABILIZATION
	;GOTO STABILIZATION

	
    BANKSEL PORTC
    
    BSF PORTC,RC7		    ; SET OUTPUT HIGH
    
    MOVLW   SIZE_COL		    ; LOAD COUNTER TO ACUM
    MOVWF   CURRENT_COLUMN	    ; ACUM TO RAM
    
    BCF	    STATUS,IRP		    ; INDIRECT BANK 0,1
    MOVLW   ARRAY_START			    ; GET START POSITION OF COLUMNS
    MOVWF   FSR			    ; INDIRECT ADDRESSING TO START
    
    
    INITIALIZE			    ; LOOP TO SET RAM
	MOVLW	0x00		    ; COLUMNS ON
	MOVWF	INDF		    ; FROM ACUM TO INDF COLUMNS ON AND OFF
	INCF	FSR,F		    ; INCREMENT INDIRECT TO INDIRECT
	
	MOVLW	0x01
	MOVWF	INDF		    ; FROM ACUM TO INDF	COLOR OF COLUMN
	INCF	FSR,F		    ; INCREMENT INDIRECT TO INDIRECT
	
	DECFSZ	CURRENT_COLUMN,F    ; DECREASE RAM COUNTER TO SELF
	GOTO	INITIALIZE

    MOVLW   0x04
    MOVWF   LAST_POS_X
    MOVLW   0x10
    MOVWF   LAST_POS_Y

    MOVLW   0xF0
    MOVWF   LAST_STATE
    MOVLW   0x00
    MOVWF   PIECE_TYPE
    
    LOGIC_LOOP
	BSF	PORTC,RC6	   
	BCF	PORTC,RC6
	
	;KEEP ALIVE ON BANK 0
	BCF	STATUS,RP1		    ;FORCE BANK 0
	BCF	STATUS,RP0
	MOVLW	0x0F
	MOVWF	B31
	CALL	RANDOM
	MOVWF	C31

	;STUFF
	CALL	PRINT_SCREEN
	CALL	GET_PIECE
	CALL	PRINT_PIECE
	
	;READ BUTTONS BEFORE LEAVING BANK 0
	MOVF	PORTB,W
	XORLW	0xF0
	MOVWF	TEMP_STATE
	
	;LOGIC ON BANK 1 BECAUSE NOT DIRECT ACCESS
	BCF	STATUS,RP1		    ;FORCE BANK 1
	BSF	STATUS,RP0
	
	;BUTTON MANAGMENT
	;COULD MAYBE BE REDUCED
	ANDLW	0x80
	BTFSC	STATUS,Z
	GOTO	BRC6
        MOVWF	TEMP_REG
	MOVF	LAST_STATE,W
	ANDLW	0x80
	XORWF	TEMP_REG,W
	BTFSS	STATUS,Z
	CALL	ROTATE
	
	BRC6
	
	MOVF	TEMP_STATE,W
	ANDLW	0x40
	BTFSC	STATUS,Z
	GOTO	BRC5
        MOVWF	TEMP_REG
	MOVF	LAST_STATE,W
	ANDLW	0x40
	XORWF	TEMP_REG,W
	BTFSS	STATUS,Z
	CALL	RIGHT
	
	BRC5
	
	MOVF	TEMP_STATE,W
	ANDLW	0x20
	BTFSC	STATUS,Z
	GOTO	BRC4
        MOVWF	TEMP_REG
	MOVF	LAST_STATE,W
	ANDLW	0x20
	XORWF	TEMP_REG,W
	BTFSS	STATUS,Z
	CALL	DOWN
	
	BRC4
	
	MOVF	TEMP_STATE,W
	ANDLW	0x10
	BTFSC	STATUS,Z
	GOTO	BEND
        MOVWF	TEMP_REG
	MOVF	LAST_STATE,W
	ANDLW	0x10
	XORWF	TEMP_REG,W
	BTFSS	STATUS,Z
	CALL	LEFT
	
	BEND
	;END BUTTONSNSNSNSNSNSN
	
	;DEBUUUUG ON BANK 0
	BCF	STATUS,RP1		    ;FORCE BANK 0
	BCF	STATUS,RP0
	
	MOVF	PIECE_TYPE,W
	MOVWF	B30
	MOVF	LAST_POS_Y,W
	SUBLW	.28
	MOVF	STATUS,W
	CALL	REVERSE_BYTE
	MOVWF	B29
	MOVF	LAST_POS_Y,W
	SUBLW	.28
	BTFSS	STATUS,C
	MOVLW	0xF0
	MOVWF	B28
	;END DEBUG
	
	END_LOGIC
	MOVF	TEMP_STATE,W
	MOVWF	LAST_STATE
	GOTO LOGIC_LOOP
END                                                   